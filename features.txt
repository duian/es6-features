##
##  es6-features -- ECMAScript 6 Feature Overview & Comparison
##  Copyright (c) 2015-2016 Ralf S. Engelschall <rse@engelschall.com>
##
##  Permission is hereby granted, free of charge, to any person obtaining
##  a copy of this software and associated documentation files (the
##  "Software"), to deal in the Software without restriction, including
##  without limitation the rights to use, copy, modify, merge, publish,
##  distribute, sublicense, and/or sell copies of the Software, and to
##  permit persons to whom the Software is furnished to do so, subject to
##  the following conditions:
##
##  The above copyright notice and this permission notice shall be included
##  in all copies or substantial portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
##  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
##  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
##  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
##  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
##


Constants
=========

Constants (常量)
---------

Support for constants (also known as "immutable variables"), i.e.,
variables which cannot be re-assigned new content. Notice: this only
makes the variable itself immutable, not its assigned content (for
instance, in case the content is an object, this means the object itself
can still be altered).

6| |const PI| = 3.141593;
6| PI > 3.0;

5| //  only in ES5 through the help of object properties
5| //  and only in global context and not in a block scope
5| Object.|defineProperty|(typeof global === "object" ? global : window, "|PI|", {
5|     value:        3.141593,
5|     enumerable:   true,
5|     |writable:     false|,
5|     |configurable: false|
5| })
5| PI > 3.0;


Scoping
=======

Block-Scoped Variables (局部变量)
----------------------

Block-scoped variables (and constants) without hoisting.

6| for (|let i| = 0; i < a.length; i++) {
6|     |let x| = a[i];
6|     ...
6| }
6| for (|let i| = 0; i < b.length; i++) {
6|     |let y| = b[i];
6|     ...
6| }
6|
6| let callbacks = [];
6| for (|let| i = 0; i <= 2; i++) {
6|     callbacks[i] = function () { return i * 2; };
6| }
6| callbacks[0]() === 0;
6| callbacks[1]() === 2;
6| callbacks[2]() === 4;

5| |var i, x, y|;
5| for (i = 0; i < a.length; i++) {
5|     x = a[i];
5|     ...
5| }
5| for (i = 0; i < b.length; i++) {
5|     y = b[i];
5|     ...
5| }
5|
5| var callbacks = [];
5| for (|var| i = 0; i <= 2; i++) {
5|     |(function (i) {|
5|         callbacks[i] = function() { return i * 2; };
5|     |})(i);|
5| }
5| callbacks[0]() === 0;
5| callbacks[1]() === 2;
5| callbacks[2]() === 4;


Block-Scoped Functions (局部作用域)
----------------------

Block-scoped function definitions.

6| {
6|     function foo () { return 1; }
6|     foo() === 1;
6|     {
6|         function |foo| () { return |2|; }
6|         |foo|() === |2|;
6|     }
6|     foo() === 1;
6| }

5| //  only in ES5 with the help of block-scope emulating
5| //  function scopes and function expressions
5| (function () {
5|     var foo = function () { return 1; }
5|     foo() === 1;
5|     |(function () {|
5|         var |foo| = function () { return |2|; }
5|         |foo|() === |2|;
5|     |})();|
5|     foo() === 1;
5| })();

Arrow Functions (箭头函数)
===============

Expression Bodies (表达式)
-----------------

More expressive closure syntax.

6| odds  = evens.map(|v =>| v + 1);
6| pairs = evens.map(|v => (|{ even: v, odd: v + 1 }|)|);
6| nums  = evens.map(|(v, i) =>| v + i);

5| odds  = evens.map(|function (v) { return| v + 1; |}|);
5| pairs = evens.map(|function (v) { return| { even: v, odd: v + 1 }; |}|);
5| nums  = evens.map(|function (v, i) { return| v + i; |}|);

Statement Bodies (声明式)
----------------

More expressive closure syntax.

6| nums.forEach(|v => {|
6|    if (v % 5 === 0)
6|        fives.push(v);
6| |}|)

5| nums.forEach(|function (v) {|
5|    if (v % 5 === 0)
5|        fives.push(v);
5| |}|);

Lexical `this` (绑定作用域)
--------------

More intuitive handling of current object context.

6| |this|.nums.forEach(|(v) =>| {
6|     if (v % 5 === 0)
6|         |this|.fives.push(v);
6| });

5| //  variant 1
5| var |self| = |this|;
5| |this|.nums.forEach(|function (v)| {
5|     if (v % 5 === 0)
5|         |self|.fives.push(v);
5| });
5|
5| //  variant 2
5| |this|.nums.forEach(|function (v)| {
5|     if (v % 5 === 0)
5|         |this|.fives.push(v);
5| }, |this|);
5|
5| //  variant 3 (since ECMAScript 5.1 only)
5| |this|.nums.forEach(|function (v)| {
5|     if (v % 5 === 0)
5|         |this|.fives.push(v);
5| }|.bind(this)|);


Extended Parameter Handling  (扩展函数参数)
===========================

Default Parameter Values (参数默认值)
------------------------

Simple and intuitive default values for function parameters.

6| function f (x, y |= 7|, z |= 42|) {
6|     return x + y + z;
6| }
6| f(1) === 50;

5| function f (x, y, z) {
5|     |if (y === undefined)|
5|         |y = 7|;
5|     |if (z === undefined)|
5|         |z = 42|;
5|     return x + y + z;
5| };
5| f(1) === 50;

Rest Parameter (rest 参数)
--------------

Aggregation of remaining arguments into single parameter of variadic functions.

6| function f (x, y, |...a|) {
6|     return (x + y) * a.length;
6| }
6| f(1, 2, |"hello", true, 7|) === 9;

5| function f (x, y) {
5|     |var a = Array.prototype.slice.call(arguments, 2)|;
5|     return (x + y) * a.length;
5| };
5| f(1, 2, |"hello", true, 7|) === 9;

Spread Operator (扩展参数)
---------------

Spreading of elements of an iterable collection (like an array or even
a string) into both literal elements and individual function parameters.

6| var params = [ "hello", true, 7 ];
6| var other = [ 1, 2, |...params| ]; // [ 1, 2, "hello", true, 7 ]
6|
6| function f (x, y, ...a) {
6|     return (x + y) * a.length;
6| }
6| f(1, 2, |...params|) === 9;
6|
6| var str = "foo";
6| var chars = [ |...str| ]; // [ "f", "o", "o" ]

5| var params = [ "hello", true, 7 ];
5| var other = [ 1, 2 ].|concat(params)|; // [ 1, 2, "hello", true, 7 ]
5|
5| function f (x, y) {
5|     var a = Array.prototype.slice.call(arguments, 2);
5|     return (x + y) * a.length;
5| };
5| f|.apply|(|undefined, [| 1, 2 |].concat(params)|) === 9;
5|
5| var str = "foo";
5| var chars = str.split(""); // [ "f", "o", "o" ]

Template Literals (模版字面量)
=================

String Interpolation (字符串变量)
--------------------

Intuitive expression interpolation for single-line and multi-line strings.
(Notice: don't be confused, Template Literals were originally named
"Template Strings" in the drafts of the ECMAScript 6 language specification)

6| var customer = { name: "Foo" };
6| var card = { amount: 7, product: "Bar", unitprice: 42 };
6| var message = |`|Hello |${customer.name}|,
6| want to buy |${card.amount} ${card.product}| for
6| a total of |${card.amount * card.unitprice}| bucks?|`|;

5| var customer = { name: "Foo" };
5| var card = { amount: 7, product: "Bar", unitprice: 42 };
5| var message = |"|Hello "| + customer.name + |",\n" +
5| "want to buy "| + card.amount + |" "| + card.product + |" for\n" +
5| "a total of "| + (card.amount * card.unitprice) + |" bucks?|"|;


Enhanced Object Properties (增强对象属性)
==========================

Property Shorthand (属性缩写)
------------------

Shorter syntax for common object property definition idiom.

6| obj = { |x|, |y| };

5| obj = { |x: x|, |y: y| };

Computed Property Names (计算属性名)
-----------------------

Support for computed names in object property definitions.

6| let obj = {
6|     foo: "bar",
6|     |[| "baz" + quux() |]:| 42
6| };

5| var obj = {
5|     foo: "bar"
5| };
5| |obj[| "baz" + quux() |] =| 42;

Method Properties (方法)
-----------------

Support for method notation in object property definitions,
for both regular functions and generator functions.

6| obj = {
6|     |foo (a, b)| {
6|         ...
6|     },
6|     |bar (x, y)| {
6|         ...
6|     },
6|     |*quux (x, y)| {
6|         ...
6|     }
6| };

5| obj = {
5|     foo|: function| (a, b) {
5|         ...
5|     },
5|     bar|: function| (x, y) {
5|         ...
5|     },
5|     //  quux: no equivalent in ES5
5|     ...
5| };


Destructuring Assignment (解构赋值)
========================

Array Matching (数组)
--------------

Intuitive and flexible destructuring of Arrays into individual variables during assignment.

6| var list = [ 1, 2, 3 ];
6| var |[ a, , b ] = list|;
6| [ |b, a| ] = [ |a, b| ];

5| var list = [ 1, 2, 3 ];
5| var |a = list[0]|, |b = list[2]|;
5| var |tmp = a|; |a = b|; |b = tmp|;

Object Matching, Shorthand Notation (对象，简写)
-----------------------------------

Intuitive and flexible destructuring of Objects into individual variables during assignment.

6| var |{ op, lhs, rhs }| = getASTNode();

5| var |tmp| = getASTNode();
5| var |op  = tmp.op|;
5| var |lhs = tmp.lhs|;
5| var |rhs = tmp.rhs|;

Object Matching, Deep Matching (嵌套匹配)
------------------------------

Intuitive and flexible destructuring of Objects into individual variables during assignment.

6| var { op: a, |lhs: { op: b }|, rhs: c } = getASTNode();

5| var tmp = getASTNode();
5| var a = tmp.op;
5| var |b = tmp.lhs.op|;
5| var c = tmp.rhs;

Object And Array Matching, Default Values (默认值)
-----------------------------------------

Simple and intuitive default values for destructuring of Objects and Arrays.

6| var obj = { a: 1 };
6| var list = [ 1 ];
6| var { a, |b = 2| } = obj;
6| var [ x, |y = 2| ] = list;

5| var obj = { a: 1 };
5| var list = [ 1 ];
5| var a = obj.a;
5| var |b = obj.b === undefined ? 2 : obj.b|;
5| var x = list[0];
5| var |y = list[1] === undefined ? 2 : list[1]|;

Parameter Context Matching (参数)
--------------------------

Intuitive and flexible destructuring of Arrays and Objects into individual parameters during function calls.

6| function f (|[ name, val ]|) {
6|     console.log(name, val);
6| }
6| function g (|{ name: n, val: v }|) {
6|     console.log(n, v);
6| }
6| function h (|{ name, val }|) {
6|     console.log(name, val);
6| }
6| f([ "bar", 42 ]);
6| g({ name: "foo", val:  7 });
6| h({ name: "bar", val: 42 });

5| function f (|arg|) {
5|     |var name = arg[0]|;
5|     |var val  = arg[1]|;
5|     console.log(name, val);
5| };
5| function g (|arg|) {
5|     |var n = arg.name|;
5|     |var v = arg.val|;
5|     console.log(n, v);
5| };
5| function h (|arg|) {
5|     |var name = arg.name|;
5|     |var val  = arg.val|;
5|     console.log(name, val);
5| };
5| f([ "bar", 42 ]);
5| g({ name: "foo", val:  7 });
5| h({ name: "bar", val: 42 });

Fail-Soft Destructuring (不会翻译)
-----------------------

Fail-soft destructuring, optionally with defaults.

6| var list = [ 7, 42 ];
6| var [ a = 1, b = 2, |c = 3|, |d| ] = list;
6| a === 7;
6| b === 42;
6| c === |3|;
6| d === |undefined|;

5| var list = [ 7, 42 ];
5| var a = typeof list[0] !== "undefined" ? list[0] : 1;
5| var b = typeof list[1] !== "undefined" ? list[1] : 2;
5| var c = typeof list[2] !== "undefined" ? list[2] : |3|;
5| var d = typeof list[3] !== "undefined" ? list[3] : |undefined|;
5| a === 7;
5| b === 42;
5| c === |3|;
5| d === |undefined|;


Modules (模块)
=======

Value Export/Import (导入/导入)
-------------------

Support for exporting/importing values from/to modules without global namespace pollution.

6| //  lib/math.js
6| |export| function |sum| (x, y) { return x + y };
6| |export| var |pi| = 3.141593;
6|
6| //  someApp.js
6| |import * as math| from "lib/math";
6| console.log("2π = " + math.sum(math.pi, math.pi));
6|
6| //  otherApp.js
6| |import { sum, pi }| from "lib/math";
6| console.log("2π = " + sum(pi, pi));

5| //  lib/math.js
5| |LibMath = {}|;
5| |LibMath.sum| = function (x, y) { return x + y };
5| |LibMath.pi| = 3.141593;
5|
5| //  someApp.js
5| var |math = LibMath|;
5| console.log("2π = " + math.sum(math.pi, math.pi));
5|
5| //  otherApp.js
5| var |sum = LibMath.sum|, |pi = LibMath.pi|;
5| console.log("2π = " + sum(pi, pi));

Default & Wildcard (默认值 & 通配符)
------------------

Marking a value as the default exported value and mass-mixin of values.

6| //  lib/mathplusplus.js
6| |export *| from "lib/math";
6| export var e = 2.71828182846;
6| |export default| (x) => Math.exp(x);
6|
6| //  someApp.js
6| |import exp, { pi, e }| from "lib/mathplusplus";
6| console.log("e^{π} = " + exp(pi));

5| //  lib/mathplusplus.js
5| |LibMathPP = {}|;
5| |for (symbol in LibMath)|
5|     |if (LibMath.hasOwnProperty(symbol))|
5|         |LibMathPP[symbol] = LibMath[symbol]|;
5| |LibMathPP.e| = 2.71828182846;
5| |LibMathPP.exp| = function (x) { return Math.exp(x) };
5|
5| //  someApp.js
5| var |exp = LibMathPP.exp|, |pi = LibMathPP.pi|, |e = LibMathPP.e|;
5| console.log("e^{π} = " + exp(pi));


Classes (类)
=======

Class Definition (类定义)
----------------

More intuitive, OOP-style and boilerplate-free classes.

6| |class| Shape {
6|     |constructor| (id, x, y) {
6|         this.id = id;
6|         this.move(x, y);
6|     }
6|     |move| (x, y) {
6|         this.x = x;
6|         this.y = y;
6|     }
6| }

5| var Shape = |function| (id, x, y) {
5|     this.id = id;
5|     this.move(x, y);
5| };
5| Shape.|prototype.move| = |function| (x, y) {
5|     this.x = x;
5|     this.y = y;
5| };

Class Inheritance (类继承)
-----------------

More intuitive, OOP-style and boilerplate-free inheritance.

6| |class| Rectangle |extends| Shape {
6|     constructor (id, x, y, width, height) {
6|         |super|(id, x, y);
6|         this.width  = width;
6|         this.height = height;
6|     }
6| }
6| |class| Circle |extends| Shape {
6|     constructor (id, x, y, radius) {
6|         |super|(id, x, y);
6|         this.radius = radius;
6|     }
6| }

5| var Rectangle = function (id, x, y, width, height) {
5|     |Shape.call|(this, id, x, y);
5|     this.width  = width;
5|     this.height = height;
5| };
5| |Rectangle.prototype = Object.create(Shape.prototype)|;
5| |Rectangle.prototype.constructor = Rectangle|;
5| var Circle = function (id, x, y, radius) {
5|     |Shape.call|(this, id, x, y);
5|     this.radius = radius;
5| };
5| |Circle.prototype = Object.create(Shape.prototype)|;
5| |Circle.prototype.constructor = Circle|;

Class Inheritance, From Expressions (基类入口)
-----------------------------------

Support for mixin-style inheritance by extending from expressions yielding
function objects. [Notice: the generic `aggregation` function is usually provided
by a library like [this one](https://github.com/rse/aggregation), of course]

6| var |aggregation| = (baseClass, ...mixins) => {
6|     let base = class _Combined extends baseClass {
6|         constructor (...args) {
6|             |super|(...args);
6|             mixins.forEach((mixin) => {
6|                 mixin.prototype.|initializer|.call(this);
6|             });
6|         }
6|     };
6|     let copyProps = (target, source) => {
6|         Object.getOwnPropertyNames(source)
6|             .concat(Object.getOwnPropertySymbols(source))
6|             .forEach((prop) => {
6|             if (prop.match(/^(?:constructor@3@prototype@3@arguments@3@caller@3@name@3@bind@3@call@3@apply@3@toString@3@length)$/))
6|                 return
6|             Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
6|         })
6|     }
6|     mixins.forEach((mixin) => {
6|         copyProps(base.prototype, mixin.prototype);
6|         copyProps(base, mixin);
6|     });
6|     return base;
6| };
6|
6| class |Colored| {
6|     |initializer| ()     { this._color = "white"; }
6|     get color ()       { return this._color; }
6|     set color (v)      { this._color = v; }
6| }
6|
6| class |ZCoord| {
6|     |initializer| ()     { this._z = 0; }
6|     get z ()           { return this._z; }
6|     set z (v)          { this._z = v; }
6| }
6|
6| class |Shape| {
6|     |constructor| (x, y) { this._x = x; this._y = y; }
6|     get x ()           { return this._x; }
6|     set x (v)          { this._x = v; }
6|     get y ()           { return this._y; }
6|     set y (v)          { this._y = v; }
6| }
6|
6| class Rectangle extends |aggregation(Shape, Colored, ZCoord)| {}
6|
6| var rect = new Rectangle(7, 42);
6| rect.|z|     = 1000;
6| rect.|color| = "red";
6| console.log(rect.x, rect.y, rect.z, rect.color);

5| var |aggregation| = function (baseClass, mixins) {
5|     var base = function () {
5|         |baseClass.apply|(this, arguments);
5|         mixins.forEach(function (mixin) {
5|             mixin.prototype.|initializer|.call(this);
5|         }.bind(this));
5|     };
5|     base.prototype = Object.create(baseClass.prototype);
5|     base.prototype.constructor = base;
5|     var copyProps = function (target, source) {
5|         Object.getOwnPropertyNames(source).forEach(function (prop) {
5|             if (prop.match(/^(?:constructor@3@prototype@3@arguments@3@caller@3@name@3@bind@3@call@3@apply@3@toString@3@length)$/))
5|                 return
5|             Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
5|         })
5|     }
5|     mixins.forEach(function (mixin) {
5|         copyProps(base.prototype, mixin.prototype);
5|         copyProps(base, mixin);
5|     });
5|     return base;
5| };
5|
5| var Colored = function () {};
5| Colored.prototype = {
5|     |initializer|: function ()  { this._color = "white"; },
5|     getColor:    function ()  { return this._color; },
5|     setColor:    function (v) { this._color = v; }
5| };
5|
5| var ZCoord = function () {};
5| ZCoord.prototype = {
5|     |initializer|: function ()  { this._z = 0; },
5|     getZ:        function ()  { return this._z; },
5|     setZ:        function (v) { this._z = v; }
5| };
5|
5| var Shape = function (x, y) {
5|     this._x = x; this._y = y;
5| };
5| Shape.prototype = {
5|     getX: function ()  { return this._x; },
5|     setX: function (v) { this._x = v; },
5|     getY: function ()  { return this._y; },
5|     setY: function (v) { this._y = v; }
5| }
5|
5| var _Combined = |aggregation(Shape, [ Colored, ZCoord ])|;
5| var Rectangle = function (x, y) {
5|     _Combined.call(this, x, y);
5| };
5| Rectangle.prototype = Object.create(_Combined.prototype);
5| Rectangle.prototype.constructor = Rectangle;
5|
5| var rect = new Rectangle(7, 42);
5| rect.|setZ|(1000);
5| rect.|setColor|("red");
5| console.log(rect.getX(), rect.getY(), rect.getZ(), rect.getColor());

Base Class Access  (基类调用)
-----------------

Intuitive access to base class constructor and methods.

6| class Shape {
6|     ...
6|     |toString| () {
6|         return `Shape(${this.id})`
6|     }
6| }
6| class Rectangle extends Shape {
6|     constructor (id, x, y, width, height) {
6|         |super|(id, x, y);
6|         ...
6|     }
6|     |toString| () {
6|         return "Rectangle > " + |super.toString()|;
6|     }
6| }
6| class Circle extends Shape {
6|     constructor (id, x, y, radius) {
6|         |super|(id, x, y);
6|         ...
6|     }
6|     |toString| () {
6|         return "Circle > " + |super.toString()|;
6|     }
6| }

5| var Shape = |function| (id, x, y) {
5|     ...
5| };
5| Shape.|prototype.toString| = function (x, y) {
5|     return "Shape(" + this.id + ")"
5| };
5| var Rectangle = function (id, x, y, width, height) {
5|     |Shape.call|(this, id, x, y);
5|     ...
5| };
5| Rectangle|.prototype.toString| = function () {
5|     return "Rectangle > " + |Shape.prototype.toString.call(this)|;
5| };
5| var Circle = function (id, x, y, radius) {
5|     |Shape.call|(this, id, x, y);
5|     ...
5| };
5| Circle|.prototype.toString| = function () {
5|     return "Circle > " + |Shape.prototype.toString.call(this)|;
5| };

Static Members (静态方法&属性)
--------------

Simple support for static class members.

6| class Rectangle extends Shape {
6|     ...
6|     |static defaultRectangle| () {
6|         return new Rectangle("default", 0, 0, 100, 100);
6|     }
6| }
6| class Circle extends Shape {
6|     ...
6|     |static defaultCircle| () {
6|         return new Circle("default", 0, 0, 100);
6|     }
6| }
6| var defRectangle = |Rectangle.defaultRectangle()|;
6| var defCircle    = |Circle.defaultCircle()|;

5| var Rectangle = function (id, x, y, width, height) {
5|     ...
5| };
5| |Rectangle.defaultRectangle| = function () {
5|     return new Rectangle("default", 0, 0, 100, 100);
5| };
5| var Circle = function (id, x, y, width, height) {
5|     ...
5| };
5| |Circle.defaultCircle| = function () {
5|     return new Circle("default", 0, 0, 100);
5| };
5| var defRectangle = |Rectangle.defaultRectangle()|;
5| var defCircle    = |Circle.defaultCircle()|;

Getter/Setter (取值&设值)
-------------

Getter/Setter also directly within classes (and not just within object
initializers, as it is possible since ECMAScript 5.1).

6| class Rectangle {
6|     constructor (width, height) {
6|         this._width  = width;
6|         this._height = height;
6|     }
6|     |set| width  (width)  { this._width = width;               }
6|     |get| width  ()       { return this._width;                }
6|     |set| height (height) { this._height = height;             }
6|     |get| height ()       { return this._height;               }
6|     |get| area   ()       { return this._width * this._height; }
6| };
6| var r = new Rectangle(50, 20);
6| r.area === 1000;

5| var Rectangle = function (width, height) {
5|     this._width  = width;
5|     this._height = height;
5| };
5| Rectangle|.prototype| = {
5|     |set| width  (width)  { this._width = width;               }|,|
5|     |get| width  ()       { return this._width;                }|,|
5|     |set| height (height) { this._height = height;             }|,|
5|     |get| height ()       { return this._height;               }|,|
5|     |get| area   ()       { return this._width * this._height; }
5| };
5| var r = new Rectangle(50, 20);
5| r.area === 1000;


Symbol Type (原始数据类型)
===========

Symbol Type
-----------

Unique and immutable data type to be used as an identifier for object properties.
Symbol can have an optional description, but for debugging purposes only.

6| Symbol("foo") |!==| Symbol("foo");
6| const foo = Symbol();
6| const bar = Symbol();
6| typeof foo === |"symbol"|;
6| typeof bar === |"symbol"|;
6| let obj = {};
6| obj[foo] = "foo";
6| obj[bar] = "bar";
6| JSON.stringify(obj); // {}
6| Object.keys(obj); // []
6| Object.getOwnPropertyNames(obj); // []
6| Object.|getOwnPropertySymbols|(obj); // [ foo, bar ]

5| // no equivalent in ES5

Map/Set
=========================

Set Data-Structure (集合)
------------------

Cleaner data-structure for common algorithms based on sets.

6| let s = |new Set()|;
6| s.|add("hello")|.|add("goodbye")|.|add("hello")|;
6| s.|size| === 2;
6| s.|has("hello")| === true;
6| for (let key |of| s.|values()|) // insertion order
6|     console.log(key);

5| var s = |{}|;
5| |s["hello"] = true|; |s["goodbye"] = true|; |s["hello"] = true|;
5| |Object.keys(s).length| === 2;
5| |s["hello"]| === true;
5| for (var key |in| s) // arbitrary order
5|     if (s.hasOwnProperty(key))
5|         console.log(s[key]);

Map Data-Structure (字典)
------------------

Cleaner data-structure for common algorithms based on maps.

6| let m = |new Map()|;
6| let s = |Symbol()|;
6| m.|set("hello", 42)|;
6| m.|set(s, 34)|;
6| m.|get(s)| === 34;
6| m.|size| === 2;
6| for (let |[ key, val ] of m.entries()|)
6|     console.log(key + " = " + val);

5| var m = |{}|;
5| // no equivalent in ES5
5| |m["hello"] = 42|;
5| // no equivalent in ES5
5| // no equivalent in ES5
5| |Object.keys(m).length| === 2;
5| for (key |in| m) {
5|     if (m.hasOwnProperty(key)) {
5|         var |val = m[key]|;
5|         console.log(key + " = " + val);
5|     }
5| }


New Built-In Methods (新增内建方法)
====================

Object Property Assignment
--------------------------

New function for assigning enumerable properties of one or more source
objects onto a destination object.

6| var dst  = { quux: 0 };
6| var src1 = { foo: |1|, bar: 2 };
6| var src2 = { foo: |3|, baz: 4 };
6| Object|.assign|(dst, src1, src2);
6| dst.quux === 0;
6| dst.foo  === |3|;
6| dst.bar  === 2;
6| dst.baz  === 4;

5| var dst  = { quux: 0 };
5| var src1 = { foo: |1|, bar: 2 };
5| var src2 = { foo: |3|, baz: 4 };
5| Object|.keys(src1).forEach|(function(k) {
5|     |dst[k] = src1[k]|;
5| });
5| Object|.keys(src2).forEach|(function(k) {
5|     |dst[k] = src2[k]|;
5| });
5| dst.quux === 0;
5| dst.foo  === |3|;
5| dst.bar  === 2;
5| dst.baz  === 4;

Array Element Finding
---------------------

New function for finding an element in an array.

6| [ 1, 3, 4, 2 ].|find|(|x =>| x > 3); // 4
6| [ 1, 3, 4, 2 ].|findIndex|(|x =>| x > 3); // 2

5| [ 1, 3, 4, 2 ].|filter|(|function (x) { return| x > 3; })|[0]|; // 4
5| // no equivalent in ES5

String Repeating
----------------

New string repeating functionality.

6| " ".|repeat|(4 * depth);
6| "foo".|repeat|(3);

5| |Array|((4 * depth) + 1).|join|(" ");
5| |Array|(3 + 1).|join|("foo");

String Searching
----------------

New specific string functions to search for a sub-string.

6| "hello".|startsWith|("ello", 1); // true
6| "hello".|endsWith|("hell", 4);   // true
6| "hello".|includes|("ell");       // true
6| "hello".|includes|("ell", 1);    // true
6| "hello".|includes|("ell", 2);    // false

5| "hello".|indexOf|("ello") === 1;    // true
5| "hello".|indexOf|("hell") === (4 |- "hell".length|); // true
5| "hello".|indexOf|("ell") !== -1;    // true
5| "hello".|indexOf|("ell", 1) !== -1; // true
5| "hello".|indexOf|("ell", 2) !== -1; // false


Meta-Programming
================

Proxying
--------

Hooking into runtime-level object meta-operations.

6| let target = {
6|     foo: "Welcome, foo"
6| };
6| let proxy = |new Proxy|(|target|, {
6|     |get (receiver, name)| {
6|         return name in receiver ? receiver[name] : `Hello, ${name}`;
6|     }
6| });
6| proxy.foo   === "Welcome, foo";
6| proxy.|world| === "Hello, |world|";

5| // no equivalent in ES5

Reflection
----------

Make calls corresponding to the object meta-operations.

6| let obj = { a: 1 };
6| Object.defineProperty(obj, "b", { value: 2 });
6| obj[Symbol("c")] = 3;
6| |Reflect.ownKeys|(obj); // [ "a", "b", Symbol(c) ]

5| var obj = { a: 1 };
5| Object.defineProperty(obj, "b", { value: 2 });
5| // no equivalent in ES5
5| |Object.getOwnPropertyNames|(obj); // [ "a", "b" ]
